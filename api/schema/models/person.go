// Code generated by ModelQ
// person.go contains model for the database table [public.person]

package models

import (
	"database/sql"
	"encoding/gob"
	"encoding/json"
	"fmt"
	"github.com/mijia/modelq/gmq"
	"strings"
)

type Person struct {
	Id            int64  `json:"id"`
	Tag           string `json:"tag"`
	FirstName     string `json:"first_name"`
	MiddleName    string `json:"middle_name"`
	LastName      string `json:"last_name"`
	AlternateName string `json:"alternate_name"`
	GroupingIds   string `json:"grouping_ids"`
}

// Start of the Person APIs.

func (obj Person) String() string {
	if data, err := json.Marshal(obj); err != nil {
		return fmt.Sprintf("<Person Id=%v>", obj.Id)
	} else {
		return string(data)
	}
}

func (obj Person) Get(dbtx gmq.DbTx) (Person, error) {
	filter := PersonObjs.FilterId("=", obj.Id)
	if result, err := PersonObjs.Select().Where(filter).One(dbtx); err != nil {
		return obj, err
	} else {
		return result, nil
	}
}

func (obj Person) Insert(dbtx gmq.DbTx) (Person, error) {
	if result, err := PersonObjs.Insert(obj).Run(dbtx); err != nil {
		return obj, err
	} else {
		if dbtx.DriverName() != "postgres" {
			if id, err := result.LastInsertId(); err != nil {
				return obj, err
			} else {
				obj.Id = id
				return obj, err
			}
		}
		return obj, nil
	}
}

func (obj Person) Update(dbtx gmq.DbTx) (int64, error) {
	fields := []string{"Tag", "FirstName", "MiddleName", "LastName", "AlternateName", "GroupingIds"}
	filter := PersonObjs.FilterId("=", obj.Id)
	if result, err := PersonObjs.Update(obj, fields...).Where(filter).Run(dbtx); err != nil {
		return 0, err
	} else {
		return result.RowsAffected()
	}
}

func (obj Person) Delete(dbtx gmq.DbTx) (int64, error) {
	filter := PersonObjs.FilterId("=", obj.Id)
	if result, err := PersonObjs.Delete().Where(filter).Run(dbtx); err != nil {
		return 0, err
	} else {
		return result.RowsAffected()
	}
}

// Start of the inner Query Api

type _PersonQuery struct {
	gmq.Query
}

func (q _PersonQuery) Where(f gmq.Filter) _PersonQuery {
	q.Query = q.Query.Where(f)
	return q
}

func (q _PersonQuery) OrderBy(by ...string) _PersonQuery {
	tBy := make([]string, 0, len(by))
	for _, b := range by {
		sortDir := ""
		if b[0] == '-' || b[0] == '+' {
			sortDir = string(b[0])
			b = b[1:]
		}
		if col, ok := PersonObjs.fcMap[b]; ok {
			tBy = append(tBy, sortDir+col)
		}
	}
	q.Query = q.Query.OrderBy(tBy...)
	return q
}

func (q _PersonQuery) GroupBy(by ...string) _PersonQuery {
	tBy := make([]string, 0, len(by))
	for _, b := range by {
		if col, ok := PersonObjs.fcMap[b]; ok {
			tBy = append(tBy, col)
		}
	}
	q.Query = q.Query.GroupBy(tBy...)
	return q
}

func (q _PersonQuery) Limit(offsets ...int64) _PersonQuery {
	q.Query = q.Query.Limit(offsets...)
	return q
}

func (q _PersonQuery) Page(number, size int) _PersonQuery {
	q.Query = q.Query.Page(number, size)
	return q
}

func (q _PersonQuery) Run(dbtx gmq.DbTx) (sql.Result, error) {
	return q.Query.Exec(dbtx)
}

type PersonRowVisitor func(obj Person) bool

func (q _PersonQuery) Iterate(dbtx gmq.DbTx, functor PersonRowVisitor) error {
	return q.Query.SelectList(dbtx, func(columns []gmq.Column, rb []sql.RawBytes) bool {
		obj := PersonObjs.toPerson(columns, rb)
		return functor(obj)
	})
}

func (q _PersonQuery) One(dbtx gmq.DbTx) (Person, error) {
	var obj Person
	err := q.Query.SelectOne(dbtx, func(columns []gmq.Column, rb []sql.RawBytes) bool {
		obj = PersonObjs.toPerson(columns, rb)
		return true
	})
	return obj, err
}

func (q _PersonQuery) List(dbtx gmq.DbTx) ([]Person, error) {
	result := make([]Person, 0, 10)
	err := q.Query.SelectList(dbtx, func(columns []gmq.Column, rb []sql.RawBytes) bool {
		obj := PersonObjs.toPerson(columns, rb)
		result = append(result, obj)
		return true
	})
	return result, err
}

// Start of the model facade Apis.

type _PersonObjs struct {
	fcMap map[string]string
}

func (o _PersonObjs) Names() (schema, tbl, alias string) {
	return "public", "person", "Person"
}

func (o _PersonObjs) Select(fields ...string) _PersonQuery {
	q := _PersonQuery{}
	if len(fields) == 0 {
		fields = []string{"Id", "Tag", "FirstName", "MiddleName", "LastName", "AlternateName", "GroupingIds"}
	}
	q.Query = gmq.Select(o, o.columns(fields...))
	return q
}

func (o _PersonObjs) Insert(obj Person) _PersonQuery {
	q := _PersonQuery{}
	q.Query = gmq.Insert(o, o.columnsWithData(obj, "Tag", "FirstName", "MiddleName", "LastName", "AlternateName", "GroupingIds"))
	return q
}

func (o _PersonObjs) Update(obj Person, fields ...string) _PersonQuery {
	q := _PersonQuery{}
	q.Query = gmq.Update(o, o.columnsWithData(obj, fields...))
	return q
}

func (o _PersonObjs) Delete() _PersonQuery {
	q := _PersonQuery{}
	q.Query = gmq.Delete(o)
	return q
}

///// Managed Objects Filters definition

func (o _PersonObjs) FilterId(op string, p int64, ps ...int64) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("id", op, params...)
}

func (o _PersonObjs) FilterTag(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("tag", op, params...)
}

func (o _PersonObjs) FilterFirstName(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("first_name", op, params...)
}

func (o _PersonObjs) FilterMiddleName(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("middle_name", op, params...)
}

func (o _PersonObjs) FilterLastName(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("last_name", op, params...)
}

func (o _PersonObjs) FilterAlternateName(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("alternate_name", op, params...)
}

func (o _PersonObjs) FilterGroupingIds(op string, p string, ps ...string) gmq.Filter {
	params := make([]interface{}, 1+len(ps))
	params[0] = p
	for i := range ps {
		params[i+1] = ps[i]
	}
	return o.newFilter("grouping_ids", op, params...)
}

///// Managed Objects Columns definition

func (o _PersonObjs) ColumnId(p ...int64) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"id", value}
}

func (o _PersonObjs) ColumnTag(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"tag", value}
}

func (o _PersonObjs) ColumnFirstName(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"first_name", value}
}

func (o _PersonObjs) ColumnMiddleName(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"middle_name", value}
}

func (o _PersonObjs) ColumnLastName(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"last_name", value}
}

func (o _PersonObjs) ColumnAlternateName(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"alternate_name", value}
}

func (o _PersonObjs) ColumnGroupingIds(p ...string) gmq.Column {
	var value interface{}
	if len(p) > 0 {
		value = p[0]
	}
	return gmq.Column{"grouping_ids", value}
}

////// Internal helper funcs

func (o _PersonObjs) newFilter(name, op string, params ...interface{}) gmq.Filter {
	if strings.ToUpper(op) == "IN" {
		return gmq.InFilter(name, params)
	}
	return gmq.UnitFilter(name, op, params[0])
}

func (o _PersonObjs) toPerson(columns []gmq.Column, rb []sql.RawBytes) Person {
	obj := Person{}
	if len(columns) == len(rb) {
		for i := range columns {
			switch columns[i].Name {
			case "id":
				obj.Id = gmq.AsInt64(rb[i])
			case "tag":
				obj.Tag = gmq.AsString(rb[i])
			case "first_name":
				obj.FirstName = gmq.AsString(rb[i])
			case "middle_name":
				obj.MiddleName = gmq.AsString(rb[i])
			case "last_name":
				obj.LastName = gmq.AsString(rb[i])
			case "alternate_name":
				obj.AlternateName = gmq.AsString(rb[i])
			case "grouping_ids":
				obj.GroupingIds = gmq.AsString(rb[i])
			}
		}
	}
	return obj
}

func (o _PersonObjs) columns(fields ...string) []gmq.Column {
	data := make([]gmq.Column, 0, len(fields))
	for _, f := range fields {
		switch f {
		case "Id":
			data = append(data, o.ColumnId())
		case "Tag":
			data = append(data, o.ColumnTag())
		case "FirstName":
			data = append(data, o.ColumnFirstName())
		case "MiddleName":
			data = append(data, o.ColumnMiddleName())
		case "LastName":
			data = append(data, o.ColumnLastName())
		case "AlternateName":
			data = append(data, o.ColumnAlternateName())
		case "GroupingIds":
			data = append(data, o.ColumnGroupingIds())
		}
	}
	return data
}

func (o _PersonObjs) columnsWithData(obj Person, fields ...string) []gmq.Column {
	data := make([]gmq.Column, 0, len(fields))
	for _, f := range fields {
		switch f {
		case "Id":
			data = append(data, o.ColumnId(obj.Id))
		case "Tag":
			data = append(data, o.ColumnTag(obj.Tag))
		case "FirstName":
			data = append(data, o.ColumnFirstName(obj.FirstName))
		case "MiddleName":
			data = append(data, o.ColumnMiddleName(obj.MiddleName))
		case "LastName":
			data = append(data, o.ColumnLastName(obj.LastName))
		case "AlternateName":
			data = append(data, o.ColumnAlternateName(obj.AlternateName))
		case "GroupingIds":
			data = append(data, o.ColumnGroupingIds(obj.GroupingIds))
		}
	}
	return data
}

var PersonObjs _PersonObjs

func init() {
	PersonObjs.fcMap = map[string]string{
		"Id":            "id",
		"Tag":           "tag",
		"FirstName":     "first_name",
		"MiddleName":    "middle_name",
		"LastName":      "last_name",
		"AlternateName": "alternate_name",
		"GroupingIds":   "grouping_ids",
	}
	gob.Register(Person{})
}
